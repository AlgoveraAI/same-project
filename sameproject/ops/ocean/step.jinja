{% autoescape off %}

import argparse as __argparse
from multiprocessing import context
import pathlib
from typing import NamedTuple
from pprint import pprint as __pp
import os
from pathlib import Path as __Path
import dill
import json
import logging
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import matplotlib.image as mpimg
import numpy as np
import random
from pathlib import Path
import pickle
from azureml.core import Run
import sys
import time

import torch
import torch.nn as nn
import torch.nn.parallel
import torch.backends.cudnn as cudnn
import torch.optim as optim
import torch.utils.data
import torchvision.datasets as dset
import torchvision.transforms as transforms
import torchvision.utils as vutils
from base64 import (
	urlsafe_b64encode as __urlsafe_b64encode,
	urlsafe_b64decode as __urlsafe_b64decode,
)

def main({{ parameter_string }}) -> NamedTuple('FuncOutput',[('context', str),]):
	__inner_code_to_execute = """
import dill
import base64
from base64 import urlsafe_b64encode, urlsafe_b64decode
from types import ModuleType as __ModuleType

{{ inner_code | replace("\\", "\\\\") | replace("\"", "\\\"") }}

__b64_string = str(urlsafe_b64encode(dill.dumps(__context_export)), encoding="ascii")

"""

if __name__ == "__main__":
	__run = Run.get_context()
	__parser = __argparse.ArgumentParser("cleanse")
	__parser.add_argument("--input_context", type=str, help="Context to run as string")
	__parser.add_argument("--run_info", type=str, help="Run info")
	__parser.add_argument("--output_context_path", type=str, help="Output context path")
	__parser.add_argument("--metadata_url", type=str, help="Metadata URL")

	__args = __parser.parse_args()

	__input_context_string = "gAR9lC4="
	__context_filename = "context.txt"
	if "__pipelinedata_context" in __args.input_context:
		context_full_path = __Path(__args.input_context) / __context_filename
		print(f"reading file: {context_full_path}")
		__input_context_string = context_full_path.read_text()
	elif __args.input_context and __args.input_context.strip():
		__input_context_string = __args.input_context.strip()

	# Need to unpack and do this here, because AML only gives
	# us the run id inside the container. Unpacking and repacking so
	# bulk of the code is unchanged.
	__run_info_dict = dill.loads(__urlsafe_b64decode(__args.run_info))
	__run_info_dict["run_id"] = __run.get_details()["runId"]

	# Returns a tuple, where the zeroth index is the string
	__output_context_tuple = main(
		__context=__input_context_string,
		__run_info=str(
			__urlsafe_b64encode(dill.dumps(__run_info_dict)), encoding="ascii"
		),
		__metadata_url=__args.metadata_url,
	)

	__p = __Path(__args.output_context_path)
	__p.mkdir(parents=True, exist_ok=True)
	__filepath = __p / __context_filename
	with __filepath.open("w+") as __f:
		__f.write(__output_context_tuple[0])

{% endautoescape %}